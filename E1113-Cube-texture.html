<!DOCTYPE html>

<html>
	<head>
		<title>Test 3</title>
		<meta charset="utf-8">
		
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<script type="importmap">
		  {
			"imports": {
			  "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
			  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/",
			  "vax": "https://boytchev.github.io/CourseVAX/lib/vax.js"
			}
		  }
		</script>
	</head>
	
	<body>
		<script type="module"> 
			
			import * as THREE from "three";
			import * as VAX from "vax"; // Да се гледа в портретен режим, нямам време да оправям. 

			VAX.init(animate);

			VAX.camera.fov = 30;
			VAX.camera.updateProjectionMatrix();
			VAX.camera.position.set(0,0,0);
			VAX.scene.background = new THREE.CubeTextureLoader().load([
						'humus/posx.jpg', 'humus/negx.jpg',
						'humus/posy.jpg', 'humus/negy.jpg',
						'humus/posz.jpg', 'humus/negz.jpg']);
			VAX.scene.background.colorSpace = THREE.LinearSRGBColorSpace;
			
			var alpha , beta , gamma, absolute;
			
			window.addEventListener("deviceorientation", deviceOrientation, true);

			function deviceOrientation(event)
			{
				console.log(event);
				alpha = event.alpha.toFixed(1);
				beta = event.beta.toFixed(1);
				gamma = event.gamma.toFixed(1);
			}
			
			var objects = [];
			function updateCameraOrientation() {
				const yawRad = THREE.MathUtils.degToRad(alpha);
				const pitchRad = THREE.MathUtils.degToRad(beta);
				const rollRad = THREE.MathUtils.degToRad(gamma);


				const screenOrientationDeg = window.orientation || 0;
				const screenOrientationRad = THREE.MathUtils.degToRad(screenOrientationDeg);

				//const adjustedYawRad = yawRad - screenOrientationRad; 
				//const adjustedRowRad = rollRad - screenOrientationRad;

				const quaternionYaw = new THREE.Quaternion().setFromAxisAngle(
					new THREE.Vector3(1, 0, 0), // Y-axis //swapped from 0, 1, 0
					yawRad 
				); 
				const quaternionPitch = new THREE.Quaternion().setFromAxisAngle(
					new THREE.Vector3(0, 1, 0), // X-axis //swapped from 1, 0, 0
					pitchRad 
				);
				const quaternionRoll = new THREE.Quaternion().setFromAxisAngle(
					new THREE.Vector3(0, 0, 1), //Z-axis
					-rollRad
				);

				const deviceQuaternion = new THREE.Quaternion()
					.multiply(quaternionYaw)
					.multiply(quaternionPitch)
					.multiply(quaternionRoll);

				const referenceQuaternion = new THREE.Quaternion().setFromEuler(
					new THREE.Euler(-Math.PI / 2, 0, 0, 'YXZ') 
				);

				const finalQuaternion = deviceQuaternion.multiply(referenceQuaternion);

				VAX.camera.quaternion.copy(finalQuaternion);
			}
			const material = new THREE.MeshPhysicalMaterial({
				roughness: 0.15,
				transmission: 1,
				thickness: 100
			});
			
			const geometry = new THREE.TorusKnotGeometry(
				18,
				4,
				172,
				19, 
				4,
				5
			);
			var distance = 800;
			var ObjCount = 60;
			for( var i = 0; i < ObjCount; i++){
				var omega = (i / ObjCount) * (Math.PI*2);  
				const refractiveObj = new THREE.Mesh(geometry, material);
				refractiveObj.position.set( distance * Math.sin(omega), Math.floor(Math.random()*400 - 200) , distance * Math.cos( omega) );
				objects.push(refractiveObj);
				VAX.scene.add(refractiveObj);
			}
			
			function animate(t)
			{
				for(var i =0; i< ObjCount; i++){
					objects[i].rotation.set( 0, t/2 , 0);
				}
				updateCameraOrientation()
			}
			
		</script>	
	</body>
</html>




